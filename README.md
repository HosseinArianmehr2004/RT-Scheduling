# پروژه RT-Scheduling

این پروژه به منظور شبیه‌سازی و مدیریت منابع و وظایف در یک سیستم چند زیرسیستم طراحی شده است. این سیستم به صورت موازی وظایف را اجرا می‌کند و زمان‌بندی آن‌ها را مدیریت می‌کند.

## مقدمه

در این پروژه، چهار زیرسیستم وجود دارد که هر کدام منابع خاص خود را مدیریت می‌کنند. هر زیرسیستم می‌تواند وظایف را بر اساس زمان ورود آن‌ها اجرا کند. این پروژه با استفاده از threading در پایتون پیاده‌سازی شده است تا امکان اجرای همزمان زیرسیستم‌ها فراهم شود.

## ساختار پروژه

پروژه شامل فایل‌های زیر است:

- **Main.py** : فایل اصلی که شبیه‌سازی را اجرا می‌کند
- **Subsystem.py** : شامل کلاس‌های زیرسیستم ها است
- **Core.py** : شامل هسته ها و پردازش وظیفه ها است
- **Task.py** : شامل کلاس‌ها و ویژگی های وظایف است

---

---

## 1- `Main.py`

### کلاس‌ها :

---

### 1-1- `Resource` :

کلاس `Resource` نمایانگر یک منبع است که شامل ویژگی‌های زیر است:

- `name`: نام منبع
- `total_units`: تعداد کل واحدهای منبع
- `available_units`: تعداد واحدهای موجود منبع

### توابع کلاس `Resource` :

### 1-1-1- `Resource.__init__(name, total_units)`

این تابع سازنده کلاس `Resource` است که ویژگی‌های زیر را تعریف می‌کند:

- `name`: نام منبع.
- `total_units`: تعداد کل واحدهای منبع.
- `available_units`: تعداد واحدهای موجود (ابتدا برابر با تعداد کل واحدها).

### 1-1-2- `Resource.__str__()` و `Resource.__repr__()`

این توابع برای نمایش اطلاعات منبع به کار می‌روند:

- `__str__`: نمایش به صورت رشته‌ای برای چاپ.
- `__repr__`: نمایش به صورت نمایشی برای دیباگینگ.

---

### 1-2- `Main` :

کلاس Main شامل گرفتن ورودی ها ، ایجاد نخ ها ، مدیریت نخ ها و نمایش خروجی ها است.

### توابع کلاس `Main` :

### 1-2-1- `run_subsystem(subsystem, tasks, time_range, subsystem_file, thread_id)`

این تابع وظیفه اجرای زیرسیستم‌ها را بر عهده دارد. مراحل زیر را انجام می‌دهد:

**مدیریت زمان** : با استفاده از `condition`، هر زیرسیستم منتظر نوبت خود می‌ماند تا وظایف را اجرا کند.

**ایجاد فایل‌های گزارش** : برای هر واحد زمانی، گزارشی از وضعیت زیرسیستم و وظایف جدید که وارد می‌شوند، ایجاد می‌کند.

**اجرای وظایف** : وظایف موجود در صف را بر اساس زمان ورود و منابع مورد نیاز اجرا می‌کند.

**ثبت وضعیت** : وضعیت زیرسیستم را در فایل‌های گزارش ثبت می‌کند.

**مدیریت نوبت** : بعد از اتمام کار، نوبت زیرسیستم بعدی را افزایش می‌دهد و دیگر زیرسیستم‌ها را مطلع می‌کند.

### 1-2-2- `main()`

این تابع اصلی‌ترین تابع برنامه است که شبیه‌سازی را اجرا می‌کند. مراحل زیر را انجام می‌دهد:

**خواندن فایل ورودی**: اطلاعات مربوط به منابع و وظایف را از فایل `in.txt` می‌خواند.

**ایجاد منابع**: بر اساس اطلاعات خوانده‌شده، منابع مختلف برای هر زیرسیستم ایجاد می‌شود.

**ایجاد زیرسیستم‌ها**: چهار زیرسیستم با منابع مشخص ایجاد می‌شود.

**خواندن وظایف**: وظایف از فایل ورودی خوانده شده و به لیست‌های مربوط به هر زیرسیستم تقسیم‌بندی می‌شوند.

**ایجاد فایل‌های خروجی**: فایل‌های خروجی برای ثبت گزارشات مربوط به هر زیرسیستم و زمان‌ها ایجاد می‌شود.

**ایجاد و شروع نخ‌ها**: برای هر زیرسیستم یک نخ ایجاد شده و شروع به اجرا می‌کند.

**انتظار برای اتمام نخ‌ها**: تا زمانی که همه نخ‌ها به اتمام نرسند، برنامه منتظر می‌ماند.

**نوشتن گزارش نهایی**: گزارشی نهایی از وضعیت وظایف در فایل `final_report.txt` نوشته می‌شود.

---

---

## 2- `Subsystem.py`

### کلاس‌ها :

---

### 2-1- `Subsystem` :

کلاس `Subsystem` نمایانگر یک زیرسیستم است که شامل ویژگی‌های زیر است:

- `id`: شناسه زیرسیستم
- `resources`: منابع مرتبط با زیرسیستم
- `ready_queue`: صف آماده برای وظایف
- `file`: فایل برای ثبت گزارشات
- `time`: زمان فعلی

### توابع کلاس `Subsystem` :

#### 2-1-1- `Subsystem.__init__(id, resources)`

سازنده کلاس `Subsystem` که ویژگی‌های زیر را تعریف می‌کند.

#### 2-1-2- `Subsystem.get_status()`

وضعیت فعلی زیرسیستم را برمی‌گرداند، شامل اطلاعات مربوط به منابع و وظایف در حال اجرا.

#### 2-1-3- `Subsystem.allocate_resources(task)`

منابع لازم برای یک وظیفه را تخصیص می‌دهد و در صورت عدم وجود منابع کافی، بازگشت `False` می‌کند.

#### 2-1-4- `Subsystem.release_resources(task)`

منابع تخصیص‌یافته به یک وظیفه را آزاد می‌کند.

#### 2-1-5- `Subsystem.execute()`

وظایف را اجرا می‌کند و زمان‌بندی آن‌ها را مدیریت می‌کند.

#### 2-1-6- `Subsystem.add_task(task)`

وظیفه‌ای را به زیرسیستم اضافه می‌کند.

#### 2-1-7- `Subsystem.draw_gantt_chart(core)`

نمودار گانت برای نمایش نتایج زمان‌بندی را رسم می‌کند.

---

### 2-2- `Subsystem_1` :

کلاس `Subsystem_1` یک زیرسیستم خاص با هسته‌های متعدد است.

### توابع کلاس `Subsystem_1` :

#### 2-2-1- `Subsystem_1.__init__(id, num_cores, resources)`

سازنده کلاس `Subsystem_1` که ویژگی‌های زیر را تعریف می‌کند.

#### 2-2-2- `Subsystem_1.get_status()`

وضعیت فعلی زیرسیستم و هسته‌های آن را برمی‌گرداند.

#### 2-2-3- `Subsystem_1.load_balancing()`

برای متعادل‌سازی بار بین هسته‌ها استفاده می‌شود.

#### 2-2-4- `Subsystem_1.select_core(task)`

هسته‌ای را بر اساس وظیفه انتخاب می‌کند.

---

### 2-3- `Subsystem_2` :

کلاس `Subsystem_2` مشابه `Subsystem_1` است.

### توابع کلاس `Subsystem_2` :

#### 2-3-1- `Subsystem_2.__init__(id, num_cores, resources)`

سازنده کلاس `Subsystem_2` که ویژگی‌های زیر را تعریف می‌کند.

#### 2-3-2- `Subsystem_2.execute()`

وظایف را با استفاده از نخ‌ها اجرا می‌کند.

#### 2-3-3- `Subsystem_2.add_task(task)`

وظیفه‌ای را به صف آماده اضافه می‌کند و آن را به هسته‌ها تخصیص می‌دهد.

---

### 2-4- `Subsystem_3` :

کلاس `Subsystem_3` به مدیریت وظایف با اولویت‌ها و زمان‌بندی‌های خاص می‌پردازد.

### توابع کلاس `Subsystem_3` :

#### 2-4-1- `Subsystem_3.__init__(id, num_cores, resources)`

سازنده کلاس `Subsystem_3` که ویژگی‌های زیر را تعریف می‌کند.

#### 2-4-2- `Subsystem_3.schedulablity()`

قابلیت زمان‌بندی وظایف را بررسی می‌کند.

#### 2-4-3- `Subsystem_3.add_task(task)`

وظیفه‌ای را به زیرسیستم اضافه می‌کند و منابع لازم را تخصیص می‌دهد.

---

### 2-5- `Subsystem_4` :

کلاس `Subsystem_4` به مدیریت وظایف با وابستگی‌های خاص می‌پردازد.

### توابع کلاس `Subsystem_4` :

#### 2-5-1- `Subsystem_4.__init__(id, num_cores, resources)`

سازنده کلاس `Subsystem_4` که ویژگی‌های زیر را تعریف می‌کند.

#### 2-5-2- `Subsystem_4.get_status()`

وضعیت فعلی زیرسیستم و هسته‌های آن را برمی‌گرداند.

#### 2-5-3- `Subsystem_4.execute()`

وظایف را با توجه به وابستگی‌ها و وضعیت صف‌ها اجرا می‌کند.

#### 2-5-4- `Subsystem_4.add_task(task)`

وظیفه‌ای را به زیرسیستم اضافه می‌کند و وضعیت آن را بررسی می‌کند.

---

---

## 3- `Core.py`

### کلاس‌ها :

---

### 3-1- `Core` :

کلاس `Core` نمایانگر یک هسته است که شامل ویژگی‌های زیر است:

- `id`: شناسه هسته
- `subsystem`: زیرسیستم مرتبط با هسته
- `current_task`: وظیفه جاری هسته
- `y_axis`, `from_x`, `to_x`: برای رسم نمودار گانت

### توابع کلاس `Core` :

#### 3-1-1- `Core.__init__(id, subsystem)`

سازنده کلاس `Core` که ویژگی‌های هسته را تعریف می‌کند.

#### 3-1-2- `Core.assign_task(task)`

وظیفه‌ای را به هسته اختصاص می‌دهد و وضعیت آن را به روز می‌کند.

#### 3-1-3- `Core.execute()`

وظیفه جاری را اجرا می‌کند و وضعیت آن را مدیریت می‌کند.

---

### 3-2- `Core_1` :

کلاس `Core_1` یک هسته خاص است که از کلاس `Core` ارث‌بری می‌کند.

### توابع کلاس `Core_1` :

#### 3-2-1- `Core_1.__init__(id, subsystem)`

سازنده کلاس `Core_1` که ویژگی‌های آن را تعریف می‌کند.

#### 3-2-2- `Core_1.assign_task(task)`

وظیفه‌ای را به هسته اختصاص می‌دهد و وضعیت آن را به روز می‌کند.

#### 3-2-3- `Core_1.execute()`

وظیفه جاری را اجرا می‌کند و وضعیت آن را مدیریت می‌کند.

---

### 3-3- `Core_2` :

کلاس `Core_2` نیز از کلاس `Core` ارث‌بری می‌کند و قابلیت‌های خاص خود را دارد.

### توابع کلاس `Core_2` :

#### 3-3-1- `Core_2.__init__(id, subsystem)`

سازنده کلاس `Core_2` که ویژگی‌های آن را تعریف می‌کند.

#### 3-3-2- `Core_2.assign_task()`

وظیفه‌ای را به هسته اختصاص می‌دهد و وضعیت منابع را بررسی می‌کند.

#### 3-3-3- `Core_2.execute()`

وظیفه جاری را اجرا می‌کند و وضعیت آن را مدیریت می‌کند.

---

### 3-4- `Core_3` :

کلاس `Core_3` یک هسته دیگر است که از کلاس `Core` ارث‌بری می‌کند.

### توابع کلاس `Core_3` :

#### 3-4-1- `Core_3.__init__(id, subsystem)`

سازنده کلاس `Core_3` که ویژگی‌های آن را تعریف می‌کند.

#### 3-4-2- `Core_3.assign_task(task)`

وظیفه‌ای را به هسته اختصاص می‌دهد و وضعیت آن را به روز می‌کند.

#### 3-4-3- `Core_3.execute()`

وظیفه جاری را اجرا می‌کند و وضعیت آن را مدیریت می‌کند.

---

### 3-5- `Core_4` :

کلاس `Core_4` نیز از کلاس `Core` ارث‌بری می‌کند و ویژگی‌های خاص خود را دارد.

### توابع کلاس `Core_4` :

#### 3-5-1- `Core_4.__init__(id, subsystem)`

سازنده کلاس `Core_4` که ویژگی‌های آن را تعریف می‌کند.

#### 3-5-2- `Core_4.assign_task()`

وظیفه‌ای را به هسته اختصاص می‌دهد.

#### 3-5-3- `Core_4.execute()`

وظیفه جاری را اجرا می‌کند و وضعیت آن را مدیریت می‌کند.

---

---

## 4- `Task.py`

### کلاس‌ها :

---

### 4-1- `Task_State` :

کلاس `Task_State` یک Enum است که وضعیت‌های مختلف یک وظیفه را تعریف می‌کند:

- `READY`: وظیفه آماده برای اجرا
- `WAITING`: وظیفه در حال انتظار
- `RUNNING`: وظیفه در حال اجرا
- `COMPLETED`: وظیفه به اتمام رسیده است

---

### 4-2- `Task` :

کلاس `Task` نمایانگر یک وظیفه است که شامل ویژگی‌های زیر است:

- `name`: نام وظیفه
- `execution_time`: زمان اجرای وظیفه
- `resources_needed`: منابع مورد نیاز برای اجرای وظیفه
- `arrival_time`: زمان ورود وظیفه
- `destination_CPU_number`: شماره CPU مقصد
- `period`: دوره تکرار وظیفه
- `number_of_repeat_times`: تعداد تکرارهای وظیفه
- `prerequisite_task_name`: نام وظیفه پیش‌نیاز
- `state`: وضعیت فعلی وظیفه (از نوع `Task_State`)
- `remaining_time`: زمان باقی‌مانده برای اتمام وظیفه
- `has_all_resources`: وضعیت داشتن تمامی منابع
- `has_Ri`: دیکشنری برای بررسی منابع خاص
- `remaining_quantum`: زمان کوانتوم باقی‌مانده
- `prerequisite`: وضعیت وظیفه پیش‌نیاز
- `execution_cores`: لیستی از هسته‌های اجرایی

### توابع کلاس `Task` :

#### 4-2-1- `Task.__init__(...)`

سازنده کلاس `Task` که ویژگی‌های وظیفه را تعریف می‌کند.

#### 4-2-2- `Task.__lt__(other)`

متد مقایسه‌ای برای مرتب‌سازی وظایف بر اساس زمان باقی‌مانده.

#### 4-2-3- `Task.__str__()`

متد برای نمایش اطلاعات وظیفه به صورت رشته.

#### 4-2-4- `Task.__repr__()`

متد برای نمایش اطلاعات وظیفه به صورت نمایشی.

## نحوه اجرا

برای اجرای پروژه، مراحل زیر را دنبال کنید:

1. اطمینان حاصل کنید که پایتون بر روی سیستم شما نصب شده است.
2. فایل ورودی `in.txt` را با اطلاعات مناسب پر کنید.
3. از طریق ترمینال یا خط فرمان به دایرکتوری پروژه بروید.
4. دستور زیر را اجرا کنید:

   ```bash
   python main.py
   ```
